import arrayToHashMap from "util/arrayToHashMap";
import { CreateOrderRequestInput, Direction2 } from "providers/graphql/hooks";
import rfdc from "rfdc";
import { YieldXPosition } from "models/YieldXPortfolio";
import { ExecutionPreferencesType } from "containers/PortfolioExecution/ExecutionPreferences/ExecutionPreferences";
import { PriceData } from "providers/graphql/hooks/usePriceAssets";

const clone = rfdc();

type OrdersWithKey = (CreateOrderRequestInput & {
  metadata: { yield: number };
  key: string;
})[];

type CreateOrderInputs = (CreateOrderRequestInput & {
  metadata: { yield: number };
})[];

export function positionsToCreateOrderInputs(
  selectedPositions: YieldXPosition[],
  selectedPricesMap: {
    [assetId: string]: PriceData;
  },
  originalPricesMap: {
    [assetId: string]: PriceData;
  },
  executionPreferences?: ExecutionPreferencesType,
  originalPositions?: YieldXPosition[]
) {
  let originalDiff: OrdersWithKey = [];
  if (originalPositions) {
    const newPositionsMap = arrayToHashMap(selectedPositions, "assetId");
    originalDiff = originalPositions
      .map(({ assetId, quantity, asset }) => {
        const updated = newPositionsMap[assetId];
        const referencePrice =
          originalPricesMap[assetId]?.price?.price || asset.price || 1;
        const yieldToMaturity =
          originalPricesMap[assetId]?.price?.yieldToMaturity;
        const yieldToWorst = originalPricesMap[assetId]?.price?.yieldToWorst;
        // @ts-expect-error
        const assetYield = asset.analytics?.yield;

        const direction =
          !updated || updated.quantity < quantity
            ? Direction2.Sell
            : Direction2.Buy;
        const order: Partial<CreateOrderRequestInput> = {
          assetId,
          direction,
          comment: "Generated by YieldX",
          spotPrice: referencePrice,
          fullFillRequired: executionPreferences?.fullFillRequired || false,
          goodTillCancel: executionPreferences?.goodTillCancel || false,
          metadata: {
            yield: yieldToWorst || yieldToMaturity || assetYield || 0
          }
        };

        if (updated) {
          const orderQuantity =
            direction === Direction2.Buy
              ? updated.quantity - quantity
              : quantity - updated.quantity;
          if (!orderQuantity) return undefined;
          if (direction === Direction2.Buy && referencePrice)
            order.priceLimit = referencePrice * 1.02;
          if (direction === Direction2.Sell && referencePrice)
            order.priceLimit = referencePrice * 0.98;
          return {
            quantity: orderQuantity,
            key: `Order-${assetId}-${Direction2.Buy}-${orderQuantity}`,
            ...order
          };
        }
        return undefined;
      })
      .filter(it => !!it) as (CreateOrderRequestInput & {
      metadata: { yield: number };
      key: string;
    })[];
  }

  const oldPositionsMap = originalPositions
    ? arrayToHashMap(originalPositions, "assetId")
    : {};
  const newPending: OrdersWithKey = selectedPositions
    .map(({ assetId, quantity, asset }) => {
      const referencePrice =
        selectedPricesMap[assetId]?.price?.price ?? asset.price;
      const yieldToMaturity =
        selectedPricesMap[assetId]?.price?.yieldToMaturity;
      const yieldToWorst = selectedPricesMap[assetId]?.price?.yieldToWorst;
      const limitPrice = (referencePrice ?? 0) * 1.02;
      // @ts-expect-error
      const assetYield = asset.analytics?.yield;

      const oldPosition = oldPositionsMap[assetId];
      // If there exist an old position with same asset ID, an order has already been created for it in the loop above
      if (oldPosition) return undefined;
      return {
        assetId,
        direction: Direction2.Buy,
        comment: "Generated by YieldX",
        quantity,
        spotPrice: referencePrice,
        priceLimit: limitPrice || undefined,
        fullFillRequired: executionPreferences?.fullFillRequired || false,
        goodTillCancel: executionPreferences?.goodTillCancel || false,
        metadata: {
          yield: yieldToWorst || yieldToMaturity || assetYield || 0
        },
        key: `Order-${assetId}-${Direction2.Buy}-${quantity}`
      };
    })
    .filter(it => !!it) as (CreateOrderRequestInput & {
    metadata: { yield: number };
    key: string;
  })[];
  return Object.values({
    ...arrayToHashMap(newPending, "key"),
    ...arrayToHashMap(originalDiff, "key")
  }).map(it => {
    const copy = clone(it);
    delete copy.key;
    return copy;
  }) as CreateOrderInputs;
}
